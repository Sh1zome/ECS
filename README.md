# Entity Component System (ECS)

**ECS** - это архитектурный паттерн, который становится всё более популярным среди разработчиков, стремящихся избежать проблем с переписыванием кода "с нуля" при внесении изменений в игровые механики. Этот подход позволяет снизить связность между различными игровыми компонентами, обеспечивая возможность добавления, удаления или изменения их независимо друг от друга, без ущерба для производительности. Давайте рассмотрим основы ECS.

## Сущности (Entities)

Сущность представляет собой любой объект в игре, будь то персонаж, кнопка в интерфейсе или событие, передаваемое между системами. Сущности не обладают свойствами сами по себе, а служат контейнерами для компонентов. По аналогии с `GameObject` в игровом движке Unity.

## Компоненты (Components)

Основная идея ECS заключается в переходе от традиционного ООП-подхода "Наследование" к подходу "Композиция вместо Наследования". Это позволяет избежать проблем при смешивании различных поведений и исключает необходимость в наследовании. Компоненты содержат только данные и не должны включать в себя логику обработки.

## Системы (Systems)

Системы в ECS - это блоки кода, которые обрабатывают набор компонентов на сущностях. Они не содержат локальных данных или ссылок на сущности и компоненты, кроме случаев оптимизации производительности. Системы отвечают только за обработку потока сущностей и компонентов.

> [!NOTE]
> ### Преимущества ECS
>
> Применение ECS позволяет комбинировать сложное поведение из простых систем, каждая из которых обрабатывает только необходимые ей данные. Это упрощает добавление и удаление систем без изменений в других частях приложения.

> [!IMPORTANT]
> ### Unity и ECS
>
> Важно отметить, что хотя Unity предоставляет функциональность, схожую с ECS, оно не является ECS полностью. В Unity `GameObject` аналогичен `ECS Entity`, а `MonoBehaviour` - это сочетание `ECS Component` и `ECS System`.

# ECS в Godot

## Почему Godot не использует ECS:

- **Архитектура с узлами и компонентами**: Godot использует более традиционный ООП подход, предоставляя узлы (Nodes), которые содержат как данные, так и логику. Это подходит под понятие композиции, но на более высоком уровне (узлы, которые вы используете, обычно более высокого уровня, чем компоненты в традиционной ECS).

- **Использование наследования**: Godot делает активное использование наследования, что приводит к более явным отношениям между классами. В Godot узел `Button`, например, наследуется от различных базовых классов до низлежащего уровня `Behavior Script`.

- **Оптимизация**: Godot уделяет внимание оптимизации, но это происходит на разных уровнях. Хотя ECS обычно приводит к оптимизации за счет организации данных в памяти, Godot использует различные оптимизации, такие как оптимизации уровня движка и оптимизации в игровой логике.

## Можно ли использовать ECS в Godot:

Хотя Godot не является строго ECS-ориентированным движком, вы можете использовать ECS в ваших проектах на Godot. Вот несколько способов:

- **Реализация собственного ECS**: Вы можете реализовать собственную систему управления сущностями и компонентами, используя инструменты и возможности Godot, такие как сигналы, узлы и скриптинг.

- **Использование сторонних решений и плагинов**: Существуют сторонние библиотеки и плагины для Godot, которые добавляют поддержку ECS или похожих концепций. Некоторые из них предлагают реализацию ECS для создания игр в Godot. _(Например [Godex](https://github.com/GodotECS/godex))_

- **Альтернативные методы оптимизации**: Godot предоставляет различные инструменты и методы оптимизации, которые могут быть использованы вместо строгого ECS подхода. Это включает в себя управление видимостью объектов, напрямую использование серверов и использование вычислений (`GPGPU`) для параллельных задач.

Таким образом, хотя Godot не является чисто ECS-ориентированным движком, вы можете использовать ECS в ваших проектах на Godot, реализуя собственные решения или используя сторонние библиотеки и плагины.

# Пример реализации ECS в Godot с использованием GDScript:

## Создание компонента:

```gdscript
# components.gd

class TransformComponent:
    var position: Vector2
    var rotation: float
    var scale: Vector2

    func _init(position: Vector2, rotation: float, scale: Vector2):
        self.position = position
        self.rotation = rotation
        self.scale = scale
```

## Создание системы:

```gdscript
# systems.gd

class MovementSystem:
    func update(entity_manager):
        var entities = entity_manager.get_entities_with_component(TransformComponent)
        for entity in entities:
            var transform = entity.get_component(TransformComponent)
            # Логика обновления позиции сущности
            transform.position += Vector2(1, 1) * delta
```

## Создание сущности и добавление компонента:

```gdscript
# main.gd

extends Node

var entity_manager = EntityManager.new()

func _ready():
    var entity = entity_manager.create_entity()
    var transform_component = TransformComponent.new(Vector2(0, 0), 0, Vector2(1, 1))
    entity.add_component(transform_component)
    entity_manager.add_entity(entity)

func _process(delta):
    MovementSystem.update(entity_manager)
```

## Менеджер сущностей:

```gdcript
# entity_manager.gd

class EntityManager:
    var entities = []

    func create_entity():
        return Entity.new()

    func add_entity(entity):
        entities.append(entity)

    func get_entities_with_component(component_type):
        var filtered_entities = []
        for entity in entities:
            if entity.has_component(component_type):
                filtered_entities.append(entity)
        return filtered_entities
```

Это простой пример реализации ECS в Godot. В этом примере мы создаем компонент `TransformComponent`, систему `MovementSystem`, создаем сущность и добавляем компонент к ней, а затем используем систему для обновления позиции всех сущностей с компонентом `TransformComponent` в игре.